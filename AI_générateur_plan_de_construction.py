# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H5leCe9-Cl2lbYR6LFee6-DrGVNK441b
"""

#1- code pour g√©n√©rer le dataset

import random
import pandas as pd

def generate_house_prompt(nb_ch, nb_sdb, salon, cuisine):
    variations = [
        f"maison avec {nb_ch} chambres, {nb_sdb} salles de bain, un salon de {salon} m¬≤ et une cuisine de {cuisine} m¬≤",
        f"une maison familiale comprenant {nb_ch} chambres, {nb_sdb} salles de bain, un grand salon de {salon} m√®tres carr√©s et une cuisine de {cuisine} m¬≤",
        f"habitation avec {nb_ch} chambres, {nb_sdb} salles d'eau, salon de {salon} m¬≤ et cuisine de {cuisine} m¬≤",
        f"une maison moderne avec {nb_ch} chambres, {nb_sdb} salles de bain, salon {salon} m¬≤ et cuisine {cuisine} m¬≤"
    ]
    return random.choice(variations)

data = []
for _ in range(10000):
    nb_ch = random.randint(1, 6)
    nb_sdb = random.randint(1, 4)
    salon = random.randint(20, 60)
    cuisine = random.randint(10, 30)
    total = salon + cuisine + nb_ch * 15 + nb_sdb * 10
    prompt = generate_house_prompt(nb_ch, nb_sdb, salon, cuisine)
    data.append([prompt, nb_ch, nb_sdb, salon, cuisine, total])

df = pd.DataFrame(data, columns=["prompt", "nb_chambres", "nb_sdb", "surf_salon", "surf_cuisine", "surf_totale"])
df.to_csv("house_dataset_large.csv", index=False)
print(f"‚úÖ Dataset g√©n√©r√© : {len(df)} exemples")
df.head(5)

"""2-construction du mod√®le d' IA et entrainnement"""

import pandas as pd
import tensorflow as tf
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras import layers, models
from sklearn.model_selection import train_test_split
import pickle

# ---- Charger le dataset ----
df = pd.read_csv("house_dataset_large.csv")

# ---- Pr√©parer les donn√©es texte ----
tokenizer = Tokenizer(num_words=5000, oov_token="<OOV>")
tokenizer.fit_on_texts(df["prompt"])
sequences = tokenizer.texts_to_sequences(df["prompt"])
padded = pad_sequences(sequences, maxlen=30, padding='post', truncating='post')

# ---- Pr√©parer les sorties ----
y = df[["nb_chambres", "nb_sdb", "surf_salon", "surf_cuisine", "surf_totale"]].values

# ---- Division train/test ----
X_train, X_test, y_train, y_test = train_test_split(padded, y, test_size=0.2, random_state=42)

# ---- Architecture CNN 1D ----
model = models.Sequential([
    layers.Embedding(input_dim=5000, output_dim=64, input_length=30),
    layers.Conv1D(128, 5, activation='relu'),
    layers.MaxPooling1D(2),
    layers.Conv1D(64, 5, activation='relu'),
    layers.GlobalMaxPooling1D(),
    layers.Dense(64, activation='relu'),
    layers.Dense(5, activation='linear')
])

model.compile(optimizer='adam', loss='mse', metrics=['mae'])
model.summary()

# ---- Entra√Ænement ----
history = model.fit(
    X_train, y_train,
    epochs=10,
    batch_size=64,
    validation_data=(X_test, y_test)
)

# ---- Sauvegarder le mod√®le ----
model.save("cnn_plan_predictor.h5")
print("‚úÖ Mod√®le sauvegard√© sous cnn_plan_predictor.h5")

# ---- Sauvegarder le tokenizer ----
with open("tokenizer.pkl", "wb") as f:
    pickle.dump(tokenizer, f)
print("‚úÖ Tokenizer sauvegard√© sous tokenizer.pkl")

"""3- g√©n√©ration du plan de construction en basant un prompt entr√© par un utilisateur"""

import yaml
import tensorflow as tf
from tensorflow.keras.preprocessing.sequence import pad_sequences
import pickle
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np

# =========================
# 1Ô∏è‚É£ Charger le mod√®le + tokenizer
# =========================
model = tf.keras.models.load_model("cnn_plan_predictor.h5", compile=False)
with open("tokenizer.pkl", "rb") as f:
    tokenizer = pickle.load(f)
print("‚úÖ Mod√®le et tokenizer charg√©s !")

# =========================
# 2Ô∏è‚É£ Fonction pour extraire les features depuis un prompt
# =========================
def extract_features_from_prompt(prompt):
    seq = tokenizer.texts_to_sequences([prompt])
    padded_seq = pad_sequences(seq, maxlen=30, padding='post', truncating='post')
    pred = model.predict(padded_seq)[0]

    features = {
        "nb_chambres": max(1, int(round(pred[0]))),
        "nb_sdb": max(1, int(round(pred[1]))),
        "surf_salon": max(5, float(pred[2])),
        "surf_cuisine": max(5, float(pred[3])),
        "surf_totale": max(20, float(pred[4]))
    }
    return features

# =========================
# 3Ô∏è‚É£ Fonction pour g√©n√©rer le plan et sauvegarder PNG + YAML
# =========================
def draw_and_save_house_plan_ordered(features, filename_prefix="house_plan"):
    fig, ax = plt.subplots(figsize=(12,10))
    total_width = 20
    total_height = 15
    wall_thickness = 0.3

    rooms_yaml = []

    # Murs ext√©rieurs
    ax.add_patch(patches.Rectangle((0,0), total_width, total_height, linewidth=3, edgecolor='black', facecolor='none'))

    # Salon et Cuisine
    salon_width = total_width * 0.6
    salon_height = total_height * 0.5
    cuisine_width = total_width - salon_width

    # Salon
    ax.add_patch(patches.Rectangle((0, total_height - salon_height), salon_width, salon_height,
                                   facecolor='whitesmoke', edgecolor='black', linewidth=2))
    ax.text(salon_width/2, total_height - salon_height/2,
            f"Salon / S√©jour\n{features['surf_salon']:.1f} m¬≤",
            ha='center', va='center', fontsize=10)
    rooms_yaml.append({
        "type": "salon",
        "x": 0,
        "y": total_height - salon_height,
        "width": salon_width,
        "height": salon_height,
        "surface": features['surf_salon']
    })

    # Cuisine
    ax.add_patch(patches.Rectangle((salon_width, total_height - salon_height), cuisine_width, salon_height,
                                   facecolor='#f4f1de', edgecolor='black', linewidth=2))
    ax.text(salon_width + cuisine_width/2, total_height - salon_height/2,
            f"Cuisine\n{features['surf_cuisine']:.1f} m¬≤",
            ha='center', va='center', fontsize=10)
    rooms_yaml.append({
        "type": "cuisine",
        "x": salon_width,
        "y": total_height - salon_height,
        "width": cuisine_width,
        "height": salon_height,
        "surface": features['surf_cuisine']
    })

    # Chambres align√©es horizontalement
    chambre_width = total_width / max(features["nb_chambres"], 1)
    chambre_height = (total_height - salon_height) * 0.8
    sdb_height = (total_height - salon_height) * 0.2

    for i in range(features["nb_chambres"]):
        x = i * chambre_width
        y = sdb_height
        ax.add_patch(patches.Rectangle((x, y), chambre_width, chambre_height,
                                       facecolor='#e0f7fa', edgecolor='black', linewidth=2))
        ax.text(x + chambre_width/2, y + chambre_height/2, f"Chambre {i+1}",
                ha='center', va='center', fontsize=9)
        rooms_yaml.append({
            "type": "chambre",
            "name": f"Chambre {i+1}",
            "x": x,
            "y": y,
            "width": chambre_width,
            "height": chambre_height,
            "surface": round(chambre_width * chambre_height, 2)
        })

    # Salles de bain align√©es en bas
    sdb_width = total_width / max(features["nb_sdb"], 1)
    for i in range(features["nb_sdb"]):
        x = i * sdb_width
        y = 0
        ax.add_patch(patches.Rectangle((x, y), sdb_width, sdb_height,
                                       facecolor='#ffe0b2', edgecolor='black', linewidth=2))
        ax.text(x + sdb_width/2, y + sdb_height/2, f"Salle de bain {i+1}",
                ha='center', va='center', fontsize=9)
        rooms_yaml.append({
            "type": "salle_de_bain",
            "name": f"Salle de bain {i+1}",
            "x": x,
            "y": y,
            "width": sdb_width,
            "height": sdb_height,
            "surface": round(sdb_width * sdb_height, 2)
        })

    # Portes et fen√™tres
    doors_yaml = [
        {"x": salon_width/2 - 0.45, "y": total_height - salon_height - wall_thickness, "orientation": "horizontal"},
        {"x": total_width*0.7, "y": sdb_height, "orientation": "horizontal"}
    ]
    windows_yaml = [
        {"x": salon_width/2 - 0.6, "y": total_height - 0.05, "orientation": "horizontal"},
        {"x": total_width - 0.05, "y": total_height*0.6, "orientation": "vertical"}
    ]

    def draw_door(x, y, orientation='horizontal'):
        if orientation == 'horizontal':
            ax.add_patch(patches.Rectangle((x, y), 0.9, 0.08, color='saddlebrown'))
        else:
            ax.add_patch(patches.Rectangle((x, y), 0.08, 0.9, color='saddlebrown'))

    def draw_window(x, y, orientation='horizontal'):
        if orientation == 'horizontal':
            ax.add_patch(patches.Rectangle((x, y), 1.2, 0.05, color='skyblue'))
        else:
            ax.add_patch(patches.Rectangle((x, y), 0.05, 1.2, color='skyblue'))

    for door in doors_yaml:
        draw_door(door["x"], door["y"], door["orientation"])
    for window in windows_yaml:
        draw_window(window["x"], window["y"], window["orientation"])

    # Affichage
    ax.set_xlim(-1, total_width+1)
    ax.set_ylim(-1, total_height+1)
    ax.set_aspect('equal')
    ax.axis('off')
    plt.title("üè† Plan de Maison Rectangulaire G√©n√©r√©", fontsize=14, fontweight='bold')

    # Sauvegarde PNG
    png_filename = f"{filename_prefix}.png"
    plt.savefig(png_filename, bbox_inches='tight')
    print(f"‚úÖ Plan sauvegard√© en PNG : {png_filename}")

    # Sauvegarde YAML complet
    yaml_filename = f"{filename_prefix}.yaml"
    full_yaml = {
        "total_width": total_width,
        "total_height": total_height,
        "wall_thickness": wall_thickness,
        "rooms": rooms_yaml,
        "doors": doors_yaml,
        "windows": windows_yaml
    }
    with open(yaml_filename, "w") as f:
        yaml.dump(full_yaml, f)
    print(f"‚úÖ Plan complet sauvegard√© en YAML pour le robot : {yaml_filename}")

    plt.show()

# =========================
# 4Ô∏è‚É£ Exemple d'utilisation
# =========================
prompt = "Maison moderne avec 3 chambres, 2 salles de bain, un p√©tit salon et une cuisine ouverte."
features = extract_features_from_prompt(prompt)
print("Features extraites :", features)

draw_and_save_house_plan_ordered(features, filename_prefix="plan_maison")